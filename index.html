<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Hair Color</title>
    <style>
      canvas {
        clear: both;
        display: block;
        mix-blend-mode: multiply;
      }

      section {
        opacity: 1;
        transition: opacity 500ms ease-in-out;
      }

      .removed {
        display: none;
      }

      .invisible {
        opacity: 0.2;
      }

      .segment {
        position: relative;
        float: left;
        width: 48%;
        margin: 2% 1%;
        z-index: 0;
      }

      .segment canvas {
        position: absolute;
        top: 0px;
        bottom: 0px;
        width: 100%;
      }

      .segment img {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <section id="demos" class="invisible">
      <!-- checkbox for hide canvas / show canvas -->
      <label for="visible"
        >Visible:
        <input type="checkbox" id="visible" checked />
      </label>
      <select name="renderMode" id="renderMode">
        <option value="category">Category</option>
        <option value="confidence">Confidence</option>
      </select>
      <select name="color" id="color"></select>
      <div class="segment">
        <canvas class="removed"></canvas>
        <img src="./assets/測試用圖_改色.jpg" crossorigin="anonymous" title="Click to get segmentation!" />
        <input type="file" class="removed" accept="image/*" />
      </div>
    </section>
    <script src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
    <script type="module">
      const COLOR_DATABASE =
        "https://docs.google.com/spreadsheets/d/e/2PACX-1vTFFONBmJrC2GaZpGYI_gjXPWnOizakJK6l5AkXyZ7NxzBhkTaejfLEQTnjpUFrR3ZR_MD3UdNJhSEj/pub?gid=0&single=true&output=tsv";
      import { ImageSegmenter, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.2";

      // Get DOM elements
      const $demosSection = $("#demos");
      const $color = $("#color");
      const $fileInput = $('input[type="file"]');
      let runningMode = "IMAGE";
      let imageSegmenter;
      let labels;

      let colors = [];
      let selectedColorIndex = 0;

      $(".segment canvas").on("click", function () {
        $(this).siblings("input").click();
      });

      // Preview selected image
      $fileInput.on("change", function (e) {
        const file = e.target.files[0];
        if (file) {
          const reader = new FileReader();
          reader.onload = (e) => {
            console.log(e.target.result);
            const $img = $(this).siblings("img");
            $img.one("load", () => {
              render($(this).parent());
            });
            $img.attr("src", e.target.result);
          };
          reader.readAsDataURL(file);
        }
      });

      await fetch(COLOR_DATABASE)
        .then((response) => response.text())
        .then((data) => {
          console.log(JSON.stringify(data));
          const [header, ...rows] = data.split("\r\n");
          console.log({ header, rows });

          const headerMap = {};
          headerMap.nameIndex = header.split("\t").findIndex((col) => col === "Color Name");
          headerMap.colorIndex = header.split("\t").findIndex((col) => col === "Color RGBA");

          if (headerMap.nameIndex === -1 || headerMap.colorIndex === -1) {
            alert("資料庫欄位錯誤");
          }

          colors = rows.map((row) => {
            const cells = row.split("\t");
            return {
              name: cells[headerMap.nameIndex],
              color: cells[headerMap.colorIndex].split(",").map((num) => parseInt(num)),
            };
          });

          console.log(colors.map((d) => d.color));

          // use jquery to replace select items, value = index, text = name
          $color.empty();
          colors.forEach((color, index) => {
            $color.append(
              $("<option>", {
                value: index,
                text: color.name,
              })
            );
          });
        });

      class HairProcessor {
        constructor(options = {}) {
          const { hairColor, renderMode, confidenceThreshold, img, canvas } = options;

          this.hairColor = hairColor;
          this.renderMode = renderMode || "category"; // category | confidence
          this.confidenceThreshold = confidenceThreshold || 0.5;
          this.img = img;
          this.canvas = canvas;
          this.imageSegmenter = null;
          this.labels = null;
        }

        async loadModel() {
          const audio = await FilesetResolver.forVisionTasks(
            "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.2/wasm"
          );
          this.imageSegmenter = await ImageSegmenter.createFromOptions(audio, {
            baseOptions: {
              modelAssetPath:
                // 2.1 hair model
                "https://storage.googleapis.com/mediapipe-models/image_segmenter/hair_segmenter/float32/latest/hair_segmenter.tflite",
              // 2.2 human model
              delegate: "GPU",
            },
            runningMode: runningMode,
            outputCategoryMask: true,
            outputConfidenceMasks: true,
          });
          this.labels = this.imageSegmenter.getLabels();
        }

        setRenderMode(mode) {
          this.renderMode = mode;
        }

        setColor(color) {
          this.hairColor = color;
        }

        async render() {
          this.canvas.width = this.img.naturalWidth;
          this.canvas.height = this.img.naturalHeight;

          const ctx = this.canvas.getContext("2d");
          ctx.drawImage(this.img, 0, 0, this.canvas.width, this.canvas.height);
          ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

          if (!this.segment) {
            this.segment = await new Promise((resolve) => {
              this.imageSegmenter.segment(this.img, (result) => resolve(result));
            });
          }

          console.log(this.segment);
          console.log(this.segment.categoryMask);
          const { width, height } = this.segment.categoryMask;
          const imageData = ctx.getImageData(0, 0, width, height).data;

          this.canvas.width = width;
          this.canvas.height = height;

          if (this.renderMode === "category") {
            const mask = this.segment.categoryMask.getAsUint8Array();
            for (let i = 0; i < mask.length; i++) {
              if (mask[i] === 0) continue;
              imageData[i * 4] = (this.hairColor[0] + imageData[i * 4]) / 2;
              imageData[i * 4 + 1] = (this.hairColor[1] + imageData[i * 4 + 1]) / 2;
              imageData[i * 4 + 2] = (this.hairColor[2] + imageData[i * 4 + 2]) / 2;
              imageData[i * 4 + 3] = (this.hairColor[3] + imageData[i * 4 + 3]) / 2;
            }
          } else {
            const confidence = this.segment.confidenceMasks[1].getAsFloat32Array();
            for (let i = 0; i < confidence.length; i++) {
              const value = confidence[i];
              if (value < this.confidenceThreshold) continue;
              const ratio = (value - this.confidenceThreshold) / (1 - this.confidenceThreshold);
              imageData[i * 4] = ((this.hairColor[0] + imageData[i * 4]) / 2) * ratio;
              imageData[i * 4 + 1] = ((this.hairColor[1] + imageData[i * 4 + 1]) / 2) * ratio;
              imageData[i * 4 + 2] = ((this.hairColor[2] + imageData[i * 4 + 2]) / 2) * ratio;
              imageData[i * 4 + 3] = ((this.hairColor[3] + imageData[i * 4 + 3]) / 2) * ratio;
            }
          }

          const uint8Array = new Uint8ClampedArray(imageData.buffer);
          const newImageData = new ImageData(uint8Array, width, height);
          ctx.putImageData(newImageData, 0, 0);
        }
      }

      const hairProcessor = new HairProcessor({
        hairColor: colors[selectedColorIndex].color,
        renderMode: "category",
        confidenceThreshold: 0.5,
        img: $(".segment img").get(0),
        canvas: $(".segment canvas").get(0),
      });
      await hairProcessor.loadModel();
      $demosSection.removeClass("invisible");
      await hairProcessor.render();
      $(".segment canvas").removeClass("removed");

      $color.on("change", async function () {
        selectedColorIndex = parseInt(this.value);
        hairProcessor.setColor(colors[selectedColorIndex].color);
        $(".segment canvas").addClass("removed");
        await hairProcessor.render();
        $(".segment canvas").removeClass("removed");
      });
      $("#renderMode").on("change", function () {
        hairProcessor.setRenderMode(this.value);
        $(".segment canvas").addClass("removed");
        hairProcessor.render();
        $(".segment canvas").removeClass("removed");
      });

      $("#visible").on("change", function () {
        if (this.checked) {
          $(".segment canvas").removeClass("removed");
        } else {
          $(".segment canvas").addClass("removed");
        }
      });
    </script>
  </body>
</html>
